/*! modernizr 3.3.1 (Custom Build) | MIT *
 * https://modernizr.com/download/?-webgl-setclasses !*/
"use strict";

!(function (e, n, t) {
  function o(e, n) {
    return typeof e === n;
  }function s() {
    var e, n, t, s, a, i, f;for (var c in l) if (l.hasOwnProperty(c)) {
      if ((e = [], n = l[c], n.name && (e.push(n.name.toLowerCase()), n.options && n.options.aliases && n.options.aliases.length))) for (t = 0; t < n.options.aliases.length; t++) e.push(n.options.aliases[t].toLowerCase());for (s = o(n.fn, "function") ? n.fn() : n.fn, a = 0; a < e.length; a++) i = e[a], f = i.split("."), 1 === f.length ? Modernizr[f[0]] = s : (!Modernizr[f[0]] || Modernizr[f[0]] instanceof Boolean || (Modernizr[f[0]] = new Boolean(Modernizr[f[0]])), Modernizr[f[0]][f[1]] = s), r.push((s ? "" : "no-") + f.join("-"));
    }
  }function a(e) {
    var n = c.className,
        t = Modernizr._config.classPrefix || "";if ((u && (n = n.baseVal), Modernizr._config.enableJSClass)) {
      var o = new RegExp("(^|\\s)" + t + "no-js(\\s|$)");n = n.replace(o, "$1" + t + "js$2");
    }Modernizr._config.enableClasses && (n += " " + t + e.join(" " + t), u ? c.className.baseVal = n : c.className = n);
  }function i() {
    return "function" != typeof n.createElement ? n.createElement(arguments[0]) : u ? n.createElementNS.call(n, "http://www.w3.org/2000/svg", arguments[0]) : n.createElement.apply(n, arguments);
  }var r = [],
      l = [],
      f = { _version: "3.3.1", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function on(e, n) {
      var t = this;setTimeout(function () {
        n(t[e]);
      }, 0);
    }, addTest: function addTest(e, n, t) {
      l.push({ name: e, fn: n, options: t });
    }, addAsyncTest: function addAsyncTest(e) {
      l.push({ name: null, fn: e });
    } },
      Modernizr = function Modernizr() {};Modernizr.prototype = f, Modernizr = new Modernizr();var c = n.documentElement,
      u = "svg" === c.nodeName.toLowerCase();Modernizr.addTest("webgl", function () {
    var n = i("canvas"),
        t = "probablySupportsContext" in n ? "probablySupportsContext" : "supportsContext";return t in n ? n[t]("webgl") || n[t]("experimental-webgl") : "WebGLRenderingContext" in e;
  }), s(), a(r), delete f.addTest, delete f.addAsyncTest;for (var p = 0; p < Modernizr._q.length; p++) Modernizr._q[p]();e.Modernizr = Modernizr;
})(window, document);
/*!
 * Useragnt
 * v0.3.1
 * 
 * Copyright (c) 2016 Yuichiroh Arai
 * Released under the MIT license
 * http://opensource.org/licenses/mit-license.php
 * 
 * detects: mobile, tablet, pc, windows, mac, linux, ios, android, edge, ie, safari, chrome, firefox, opera
!*/
"use strict";

!(function (e, o) {
  function i(e) {
    return n.indexOf(e) != -1;
  }function r(e) {
    var o = e.split("."),
        i = {};return i.str = e, i.float = parseFloat(e) || 0, i.major = o.length > 0 ? parseInt(o[0]) || 0 : 0, i.minor = o.length > 1 ? parseInt(o[1]) || 0 : 0, i.build = o.length > 2 ? parseInt(o[2]) || 0 : 0, i.revision = o.length > 3 ? parseInt(o[3]) || 0 : 0, i;
  }var a = {};a._detects = ["mobile", "tablet", "pc", "windows", "mac", "linux", "ios", "android", "edge", "ie", "safari", "chrome", "firefox", "opera"];var n = a.userAgent = e.navigator.userAgent.toLowerCase();a.mobile = i("iphone") || i("ipod") || i("android") && i("mobile") || i("windows") && i("phone") || i("firefox") && i("mobile") || i("blackberry"), a.tablet = i("ipad") || i("android") && !i("mobile") || i("windows") && i("touch") && !i("tablet pc") || i("firefox") && i("tablet") || i("kindle") || i("silk") || i("playbook"), a.pc = !i("iphone") && !i("ipod") && !i("ipad") && !i("android") && (!i("windows") || !i("phone") && (!i("touch") || i("tablet pc"))) && (!i("firefox") || !i("mobile") && !i("tablet")) && !i("blackberry") && !i("kindle") && !i("silk") && !i("playbook"), a.windows = i("windows"), a.mac = i("mac os x") && !i("iphone") && !i("ipad") && !i("ipod"), a.linux = i("linux") && !i("android"), a.ios = i("iphone") || i("ipad") || i("ipod"), a.ios && (a.ios = new Boolean(!0), n.match(/ os ([\d_]+)/g), a.ios.version = r(RegExp.$1.replace("_", "."))), a.android = i("android"), a.android && (a.android = new Boolean(!0), n.match(/android ([\d\.]+)/g), a.android.version = r(RegExp.$1)), a.edge = i("edge"), a.ie = i("trident") || i("msie"), a.safari = i("safari") && !i("android") && !i("edge") && !i("opera") && !i("opr") && !i("chrome"), a.chrome = i("chrome") && !i("edge") && !i("opera") && !i("opr"), a.chrome && (a.chrome = new Boolean(!0), n.match(/chrome\/([\d.]+)/g), a.chrome.version = r(RegExp.$1)), a.firefox = i("firefox") && !i("edge"), a.opera = i("opera") || i("opr");var d,
      t,
      s,
      l = a._classPrefix = "",
      p = o.documentElement,
      c = p.className;for (t = a._detects.length, d = 0; d < t; d++) s = a._detects[d], c += a[s] ? " " + l + s : " " + l + "no-" + s;p.className = c, e.Useragnt = a;
})(window, document);
/**
 * @author yomboprime https://github.com/yomboprime
 *
 * GPUComputationRenderer, based on SimulationRenderer by zz85
 *
 * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats
 * for each compute element (texel)
 *
 * Each variable has a fragment shader that defines the computation made to obtain the variable in question.
 * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader
 * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.
 *
 * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used
 * as inputs to render the textures of the next frame.
 *
 * The render targets of the variables can be used as input textures for your visualization shaders.
 *
 * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.
 * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...
 *
 * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:
 * #DEFINE resolution vec2( 1024.0, 1024.0 )
 *
 * -------------
 *
 * Basic use:
 *
 * // Initialization...
 *
 * // Create computation renderer
 * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );
 *
 * // Create initial state float textures
 * var pos0 = gpuCompute.createTexture();
 * var vel0 = gpuCompute.createTexture();
 * // and fill in here the texture data...
 *
 * // Add texture variables
 * var velVar = gpuCompute.addVariable( "textureVelocity", fragmentShaderVel, pos0 );
 * var posVar = gpuCompute.addVariable( "texturePosition", fragmentShaderPos, vel0 );
 *
 * // Add variable dependencies
 * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );
 * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );
 *
 * // Add custom uniforms
 * velVar.material.uniforms.time = { value: 0.0 };
 *
 * // Check for completeness
 * var error = gpuCompute.init();
 * if ( error !== null ) {
 *		console.error( error );
  * }
 *
 *
 * // In each frame...
 *
 * // Compute!
 * gpuCompute.compute();
 *
 * // Update texture uniforms in your visualization materials with the gpu renderer output
 * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;
 *
 * // Do your rendering
 * renderer.render( myScene, myCamera );
 *
 * -------------
 *
 * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)
 * Note that the shaders can have multiple input textures.
 *
 * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );
 * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );
 *
 * var inputTexture = gpuCompute.createTexture();
 *
 * // Fill in here inputTexture...
 *
 * myFilter1.uniforms.theTexture.value = inputTexture;
 *
 * var myRenderTarget = gpuCompute.createRenderTarget();
 * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;
 *
 * var outputRenderTarget = gpuCompute.createRenderTarget();
 *
 * // Now use the output texture where you want:
 * myMaterial.uniforms.map.value = outputRenderTarget.texture;
 *
 * // And compute each frame, before rendering to screen:
 * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );
 * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );
 * 
 *
 *
 * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.
 * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.
 * @param {WebGLRenderer} renderer The renderer
  */

"use strict";

function GPUComputationRenderer(sizeX, sizeY, renderer) {

	this.variables = [];

	this.currentTextureIndex = 0;

	var scene = new THREE.Scene();

	var camera = new THREE.Camera();
	camera.position.z = 1;

	var passThruUniforms = {
		texture: { value: null }
	};

	var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);

	var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), passThruShader);
	scene.add(mesh);

	this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {

		var material = this.createShaderMaterial(computeFragmentShader);

		var variable = {
			name: variableName,
			initialValueTexture: initialValueTexture,
			material: material,
			dependencies: null,
			renderTargets: [],
			wrapS: null,
			wrapT: null,
			minFilter: THREE.NearestFilter,
			magFilter: THREE.NearestFilter
		};

		this.variables.push(variable);

		return variable;
	};

	this.setVariableDependencies = function (variable, dependencies) {

		variable.dependencies = dependencies;
	};

	this.init = function () {

		if (!renderer.extensions.get("OES_texture_float")) {

			return "No OES_texture_float support for float textures.";
		}

		if (renderer.capabilities.maxVertexTextures === 0) {

			return "No support for vertex shader textures.";
		}

		for (var i = 0; i < this.variables.length; i++) {

			var variable = this.variables[i];

			// Creates rendertargets and initialize them with input texture
			variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
			variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
			this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
			this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);

			// Adds dependencies uniforms to the ShaderMaterial
			var material = variable.material;
			var uniforms = material.uniforms;
			if (variable.dependencies !== null) {

				for (var d = 0; d < variable.dependencies.length; d++) {

					var depVar = variable.dependencies[d];

					if (depVar.name !== variable.name) {

						// Checks if variable exists
						var found = false;
						for (var j = 0; j < this.variables.length; j++) {

							if (depVar.name === this.variables[j].name) {
								found = true;
								break;
							}
						}
						if (!found) {
							return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
						}
					}

					uniforms[depVar.name] = { value: null };

					material.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material.fragmentShader;
				}
			}
		}

		this.currentTextureIndex = 0;

		return null;
	};

	this.compute = function () {

		var currentTextureIndex = this.currentTextureIndex;
		var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;

		for (var i = 0, il = this.variables.length; i < il; i++) {

			var variable = this.variables[i];

			// Sets texture dependencies uniforms
			if (variable.dependencies !== null) {

				var uniforms = variable.material.uniforms;
				for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {

					var depVar = variable.dependencies[d];
					// console.log(depVar);

					uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;
				}
			}

			// Performs the computation for this variable
			this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);
		}

		this.currentTextureIndex = nextTextureIndex;
	};

	this.getCurrentRenderTarget = function (variable) {

		return variable.renderTargets[this.currentTextureIndex];
	};

	this.getAlternateRenderTarget = function (variable) {

		return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
	};

	function addResolutionDefine(materialShader) {

		materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + " )";
	};
	this.addResolutionDefine = addResolutionDefine;

	// The following functions can be used to compute things manually

	function createShaderMaterial(computeFragmentShader, uniforms) {

		uniforms = uniforms || {};

		var material = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: getPassThroughVertexShader(),
			fragmentShader: computeFragmentShader
		});

		addResolutionDefine(material);

		return material;
	};
	this.createShaderMaterial = createShaderMaterial;

	this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {

		sizeXTexture = sizeXTexture || sizeX;
		sizeYTexture = sizeYTexture || sizeY;

		wrapS = wrapS || THREE.ClampToEdgeWrapping;
		wrapT = wrapT || THREE.ClampToEdgeWrapping;

		minFilter = minFilter || THREE.NearestFilter;
		magFilter = magFilter || THREE.NearestFilter;

		var floatType = Useragnt.ios ? THREE.HalfFloatType : THREE.FloatType;

		var renderTarget = new THREE.WebGLRenderTarget(sizeXTexture, sizeYTexture, {
			wrapS: wrapS,
			wrapT: wrapT,
			minFilter: minFilter,
			magFilter: magFilter,
			format: THREE.RGBAFormat,
			type: floatType,
			stencilBuffer: false
		});

		return renderTarget;
	};

	this.createTexture = function (sizeXTexture, sizeYTexture) {

		sizeXTexture = sizeXTexture || sizeX;
		sizeYTexture = sizeYTexture || sizeY;

		var floatType = Useragnt.ios ? THREE.HalfFloatType : THREE.FloatType;

		var a = new Float32Array(sizeXTexture * sizeYTexture * 4);
		var texture = new THREE.DataTexture(a, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType);
		texture.needsUpdate = true;

		return texture;
	};

	this.renderTexture = function (input, output) {

		// Takes a texture, and render out in rendertarget
		// input = Texture
		// output = RenderTarget

		passThruUniforms.texture.value = input;

		this.doRenderTarget(passThruShader, output);

		passThruUniforms.texture.value = null;
	};

	this.doRenderTarget = function (material, output) {

		mesh.material = material;
		renderer.render(scene, camera, output);
		mesh.material = passThruShader;
	};

	// Shaders

	function getPassThroughVertexShader() {

		return "void main()	{\n" + "\n" + "	gl_Position = vec4( position, 1.0 );\n" + "\n" + "}\n";
	}

	function getPassThroughFragmentShader() {

		return "uniform sampler2D texture;\n" + "\n" + "void main() {\n" + "\n" + "	vec2 uv = gl_FragCoord.xy / resolution.xy;\n" + "\n" + "	gl_FragColor = texture2D( texture, uv );\n" + "\n" + "}\n";
	}
}
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

'use strict';

THREE.OrbitControls = function (object, domElement) {

	this.object = object;

	this.domElement = domElement !== undefined ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;
	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;
	};

	this.reset = function () {

		scope.target.copy(scope.target0);
		scope.object.position.copy(scope.position0);
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent(changeEvent);

		scope.update();

		state = STATE.NONE;
	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = (function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy(position).sub(scope.target);

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion(quat);

			// angle from z-axis around y-axis
			spherical.setFromVector3(offset);

			if (scope.autoRotate && state === STATE.NONE) {

				rotateLeft(getAutoRotationAngle());
			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

			// restrict phi to be between desired limits
			spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

			spherical.makeSafe();

			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

			// move target to panned location
			scope.target.add(panOffset);

			offset.setFromSpherical(spherical);

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion(quatInverse);

			position.copy(scope.target).add(offset);

			scope.object.lookAt(scope.target);

			if (scope.enableDamping === true) {

				sphericalDelta.theta *= 1 - scope.dampingFactor;
				sphericalDelta.phi *= 1 - scope.dampingFactor;
			} else {

				sphericalDelta.set(0, 0, 0);
			}

			scale = 1;
			panOffset.set(0, 0, 0);

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

				scope.dispatchEvent(changeEvent);

				lastPosition.copy(scope.object.position);
				lastQuaternion.copy(scope.object.quaternion);
				zoomChanged = false;

				return true;
			}

			return false;
		};
	})();

	this.dispose = function () {

		scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
		scope.domElement.removeEventListener('mousedown', onMouseDown, false);
		scope.domElement.removeEventListener('wheel', onMouseWheel, false);

		scope.domElement.removeEventListener('touchstart', onTouchStart, false);
		scope.domElement.removeEventListener('touchend', onTouchEnd, false);
		scope.domElement.removeEventListener('touchmove', onTouchMove, false);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		window.removeEventListener('keydown', onKeyDown, false);

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);
	}

	function rotateLeft(angle) {

		sphericalDelta.theta -= angle;
	}

	function rotateUp(angle) {

		sphericalDelta.phi -= angle;
	}

	var panLeft = (function () {

		var v = new THREE.Vector3();

		return function panLeft(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
			v.multiplyScalar(-distance);

			panOffset.add(v);
		};
	})();

	var panUp = (function () {

		var v = new THREE.Vector3();

		return function panUp(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
			v.multiplyScalar(distance);

			panOffset.add(v);
		};
	})();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = (function () {

		var offset = new THREE.Vector3();

		return function pan(deltaX, deltaY) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if (scope.object instanceof THREE.PerspectiveCamera) {

				// perspective
				var position = scope.object.position;
				offset.copy(position).sub(scope.target);
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
				panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
			} else if (scope.object instanceof THREE.OrthographicCamera) {

				// orthographic
				panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
				panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
			} else {

				// camera neither orthographic nor perspective
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
				scope.enablePan = false;
			}
		};
	})();

	function dollyIn(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale /= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	function dollyOut(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale *= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate(event) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownDolly(event) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownPan(event) {

		//console.log( 'handleMouseDownPan' );

		panStart.set(event.clientX, event.clientY);
	}

	function handleMouseMoveRotate(event) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set(event.clientX, event.clientY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleMouseMoveDolly(event) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set(event.clientX, event.clientY);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyIn(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyOut(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleMouseMovePan(event) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set(event.clientX, event.clientY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleMouseUp(event) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel(event) {

		// console.log( 'handleMouseWheel' );

		if (event.deltaY < 0) {

			dollyOut(getZoomScale());
		} else if (event.deltaY > 0) {

			dollyIn(getZoomScale());
		}

		scope.update();
	}

	function handleKeyDown(event) {

		//console.log( 'handleKeyDown' );

		switch (event.keyCode) {

			case scope.keys.UP:
				pan(0, scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan(0, -scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.LEFT:
				pan(scope.keyPanSpeed, 0);
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan(-scope.keyPanSpeed, 0);
				scope.update();
				break;

		}
	}

	function handleTouchStartRotate(event) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchStartDolly(event) {

		//console.log( 'handleTouchStartDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyStart.set(0, distance);
	}

	function handleTouchStartPan(event) {

		//console.log( 'handleTouchStartPan' );

		panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchMoveRotate(event) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleTouchMoveDolly(event) {

		//console.log( 'handleTouchMoveDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyEnd.set(0, distance);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyOut(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyIn(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleTouchMovePan(event) {

		//console.log( 'handleTouchMovePan' );

		panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleTouchEnd(event) {}

	//console.log( 'handleTouchEnd' );

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (event.button === scope.mouseButtons.ORBIT) {

			if (scope.enableRotate === false) return;

			handleMouseDownRotate(event);

			state = STATE.ROTATE;
		} else if (event.button === scope.mouseButtons.ZOOM) {

			if (scope.enableZoom === false) return;

			handleMouseDownDolly(event);

			state = STATE.DOLLY;
		} else if (event.button === scope.mouseButtons.PAN) {

			if (scope.enablePan === false) return;

			handleMouseDownPan(event);

			state = STATE.PAN;
		}

		if (state !== STATE.NONE) {

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);

			scope.dispatchEvent(startEvent);
		}
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (state === STATE.ROTATE) {

			if (scope.enableRotate === false) return;

			handleMouseMoveRotate(event);
		} else if (state === STATE.DOLLY) {

			if (scope.enableZoom === false) return;

			handleMouseMoveDolly(event);
		} else if (state === STATE.PAN) {

			if (scope.enablePan === false) return;

			handleMouseMovePan(event);
		}
	}

	function onMouseUp(event) {

		if (scope.enabled === false) return;

		handleMouseUp(event);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

		event.preventDefault();
		event.stopPropagation();

		handleMouseWheel(event);

		scope.dispatchEvent(startEvent); // not sure why these are here...
		scope.dispatchEvent(endEvent);
	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

		handleKeyDown(event);
	}

	function onTouchStart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;

				handleTouchStartRotate(event);

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;

				handleTouchStartDolly(event);

				state = STATE.TOUCH_DOLLY;

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;

				handleTouchStartPan(event);

				state = STATE.TOUCH_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if (state !== STATE.NONE) {

			scope.dispatchEvent(startEvent);
		}
	}

	function onTouchMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;
				if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

				handleTouchMoveRotate(event);

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;
				if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

				handleTouchMoveDolly(event);

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;
				if (state !== STATE.TOUCH_PAN) return; // is this needed?...

				handleTouchMovePan(event);

				break;

			default:

				state = STATE.NONE;

		}
	}

	function onTouchEnd(event) {

		if (scope.enabled === false) return;

		handleTouchEnd(event);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onContextMenu(event) {

		event.preventDefault();
	}

	//

	scope.domElement.addEventListener('contextmenu', onContextMenu, false);

	scope.domElement.addEventListener('mousedown', onMouseDown, false);
	scope.domElement.addEventListener('wheel', onMouseWheel, false);

	scope.domElement.addEventListener('touchstart', onTouchStart, false);
	scope.domElement.addEventListener('touchend', onTouchEnd, false);
	scope.domElement.addEventListener('touchmove', onTouchMove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start

	this.update();
};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

Object.defineProperties(THREE.OrbitControls.prototype, {

	center: {

		get: function get() {

			console.warn('THREE.OrbitControls: .center has been renamed to .target');
			return this.target;
		}

	},

	// backward compatibility

	noZoom: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			return !this.enableZoom;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			this.enableZoom = !value;
		}

	},

	noRotate: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			return !this.enableRotate;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			this.enableRotate = !value;
		}

	},

	noPan: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			return !this.enablePan;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			this.enablePan = !value;
		}

	},

	noKeys: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			return !this.enableKeys;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			this.enableKeys = !value;
		}

	},

	staticMoving: {

		get: function get() {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			return !this.enableDamping;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			this.enableDamping = !value;
		}

	},

	dynamicDampingFactor: {

		get: function get() {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			return this.dampingFactor;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			this.dampingFactor = value;
		}

	}

});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var ColorTex = (function () {
  function ColorTex(webgl) {
    _classCallCheck(this, ColorTex);

    this.webgl = webgl;
    this.controls = this.webgl.controls;
    this.size = this.webgl.size;

    this.colorPallete = [];

    var _colorPallete = this.controls.props.pallete;

    for (var i = 0; i < _colorPallete.length; i++) {
      this.colorPallete[i] = new THREE.Color(_colorPallete[i]);
    }

    this.objType = [new THREE.TorusBufferGeometry(8, 4, 18, 32), new THREE.TorusBufferGeometry(14, 3, 5, 3), new THREE.BoxBufferGeometry(12, 12, 12), new THREE.TorusBufferGeometry(16, 2, 5, 6)];

    this.objTypeName = ['ring', 'triangle', 'box', 'hexagon'];

    this.objNum = 0;
    this.init();
  }

  _createClass(ColorTex, [{
    key: 'init',
    value: function init() {
      this.width = this.webgl.width;
      this.height = this.webgl.height;
      this.scene = new THREE.Scene();

      this.camera = new THREE.PerspectiveCamera(70, this.width / this.height, .01, 10000);
      this.scene.add(this.camera);
      this.camera.position.set(-1, 3, 1);
      this.camera.lookAt(this.scene.position);

      var renderTargetParameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
      };

      this.fbo = new THREE.WebGLRenderTarget(this.width, this.height, renderTargetParameters);
      this.fbo.texture.format = THREE.RGBAFormat;

      this.group = new THREE.Group();
      this.scene.add(this.group);

      this.orbitControls = new THREE.OrbitControls(this.camera, this.webgl.renderer.domElement);

      this.sim = new Simulation(this.webgl, this.size);

      var scale = {
        x: 1,
        y: 1,
        z: 1
      };

      this.material = new THREE.ShaderMaterial({
        uniforms: {
          posMap: { type: "t", value: this.sim.gpuCompute.getCurrentRenderTarget(this.sim.pos).texture },
          velMap: { type: "t", value: this.sim.gpuCompute.getCurrentRenderTarget(this.sim.vel).texture },
          uSize: { type: "f", value: this.sim.size },
          uTick: { type: 'f', value: 0 },
          uScale2: { type: 'v3', value: new THREE.Vector3(scale.x, scale.y, scale.z) },
          uScale1: { type: 'f', value: 0.7 },
          uColorArray: { type: "v3v", value: this.colorPallete },
          isEdge: { type: 'i', value: true },
          uEdgeScale: { type: 'f', value: this.controls.props.edgeSize },
          uEdgeColor: { type: 'vec3', value: new THREE.Color(this.controls.props.edgeColor) },
          isShading: { type: 'i', value: this.controls.props.shading }
        },

        vertexShader: this.webgl.vertShader[1],
        fragmentShader: this.webgl.fragShader[4],
        side: THREE.DoubleSide,
        flatShading: true,
        transparent: true
      });

      for (var i = 0; i < this.objType.length; i++) {
        var originalG = this.objType[i];
        var edgesOriginalG = new THREE.EdgesGeometry(originalG);
        var EdgeVertices = edgesOriginalG.attributes.position.array;

        var posOrder = this.calcSameVert(originalG);
        originalG = this.calcVertNormal(originalG, posOrder, EdgeVertices);

        var mesh = this.createObj(originalG);

        this.objType[i] = mesh;
      }
    }
  }, {
    key: 'calcVertNormal',
    value: function calcVertNormal(originalG, posOrder, edgeVertices) {
      var length = posOrder.array.length;
      var vertNormal = [];
      var faceNormal = originalG.attributes.normal.array;
      var originalVertices = originalG.attributes.position.array;

      for (var i = 0; i <= posOrder.maxCount; i++) {
        var orderNumArray = [];
        var normalSum = { x: 0, y: 0, z: 0 };
        var count = 0;

        for (var j = 0; j < length; j++) {
          if (posOrder.array[j] === i) {
            var pos = {
              x: originalVertices[j * 3 + 0],
              y: originalVertices[j * 3 + 1],
              z: originalVertices[j * 3 + 2]
            };

            var detectEdge = this.detectEdge(pos, edgeVertices);

            orderNumArray.push(j);

            if (detectEdge) {
              normalSum.x += faceNormal[j * 3 + 0];
              normalSum.y += faceNormal[j * 3 + 1];
              normalSum.z += faceNormal[j * 3 + 2];
            } else {}

            count++;
          }
        }

        normalSum.x /= count;
        normalSum.y /= count;
        normalSum.z /= count;

        var vecLength = Math.sqrt(normalSum.x * normalSum.x + normalSum.y * normalSum.y + normalSum.z * normalSum.z);

        if (vecLength !== 0) {
          normalSum.x /= vecLength;
          normalSum.y /= vecLength;
          normalSum.z /= vecLength;
        }

        for (var k = 0; k < count; k++) {
          var num = orderNumArray[k];
          vertNormal[num * 3 + 0] = normalSum.x;
          vertNormal[num * 3 + 1] = normalSum.y;
          vertNormal[num * 3 + 2] = normalSum.z;
        }
      }

      var vertNormals = new THREE.Float32BufferAttribute(vertNormal, 3);
      originalG.addAttribute("vertNormal", vertNormals);
      return originalG;
    }
  }, {
    key: 'detectEdge',
    value: function detectEdge(vec3, edgeVertices) {
      var isSame = false;
      for (var i = 0, len = edgeVertices.length; i < len; i += 3) {
        var edgeVert = {};
        edgeVert.x = edgeVertices[i + 0];
        edgeVert.y = edgeVertices[i + 1];
        edgeVert.z = edgeVertices[i + 2];

        isSame = Math.abs(vec3.x - edgeVert.x) < 0.001 && Math.abs(vec3.y - edgeVert.y) < 0.001 && Math.abs(vec3.z - edgeVert.z) < 0.001;
        if (isSame) break;
      }

      return isSame;
    }
  }, {
    key: 'calcSameVert',
    value: function calcSameVert(geometry) {
      this.verticesArray = geometry.attributes.position.array;
      var arrayLength = this.verticesArray.length;

      this.vecCount = 0;
      this.indexCount = 0;
      this.vec3Array = [];

      this.vertexArray = [];
      var posOrderArray = [];

      for (var i = 0; i < arrayLength; i += 3) {
        var vec3 = {};
        vec3.x = this.verticesArray[i];
        vec3.y = this.verticesArray[i + 1];
        vec3.z = this.verticesArray[i + 2];
        var detect = this.detectVec(vec3);

        if (detect === 0 || detect > 0) {
          posOrderArray[this.indexCount] = detect;
        } else {
          this.vec3Array[this.vecCount] = vec3;
          this.vertexArray.push(vec3.x, vec3.y, vec3.z);

          posOrderArray[this.indexCount] = this.vecCount;

          this.vecCount++;
        }

        this.indexCount++;
      }

      return { array: posOrderArray, maxCount: this.vecCount - 1 };
    }
  }, {
    key: 'detectVec',
    value: function detectVec(vec3) {
      if (this.vecCount === 0) return false;

      for (var i = 0, len = this.vec3Array.length; i < len; i++) {
        var _vec3 = this.vec3Array[i];
        var isSame = Math.abs(vec3.x - _vec3.x) < 0.001 && Math.abs(vec3.y - _vec3.y) < 0.001 && Math.abs(vec3.z - _vec3.z) < 0.001;
        if (isSame) {
          return i;
        }
      }

      return false;
    }
  }, {
    key: 'createObj',
    value: function createObj(originalG) {
      var geometry = new THREE.InstancedBufferGeometry();
      var vertices = originalG.attributes.position.clone();

      geometry.addAttribute("position", vertices);

      var normals = originalG.attributes.normal.clone();
      geometry.addAttribute("normal", normals);

      var vertNormals = originalG.attributes.vertNormal.clone();
      geometry.addAttribute("vertNormal", vertNormals);

      // uv
      var uvs = originalG.attributes.uv.clone();
      geometry.addAttribute("uv", uvs);

      // index
      if (originalG.index) {
        var indices = originalG.index.clone();
        geometry.setIndex(indices);
      }

      geometry.maxInstancedCount = this.sim.size * this.sim.size;

      var nums = new THREE.InstancedBufferAttribute(new Float32Array(this.sim.size * this.sim.size * 1), 1, 1);
      var numRatios = new THREE.InstancedBufferAttribute(new Float32Array(this.sim.size * this.sim.size * 1), 1, 1);

      for (var i = 0; i < nums.count; i++) {
        nums.setX(i, i);
        numRatios.setX(i, i / (nums.count - 1));
      }

      geometry.addAttribute("aNum", nums);
      geometry.addAttribute("aNumRatio", numRatios);

      var mesh = new THREE.Mesh(geometry, this.material);

      mesh.visible = false;
      this.group.add(mesh);

      return mesh;
    }
  }, {
    key: 'render',
    value: function render(time, delta) {
      this.webgl.renderer.clearTarget(this.fbo);

      var sin = (Math.sin(time) * 0.5 + 0.5) * 0.5;

      var mesh = this.objType[this.objNum];

      this.group.rotation.x += delta * 0.1;
      this.group.rotation.y -= delta * 0.08;

      this.sim.velUniforms.timer.value = time;
      this.sim.velUniforms.delta.value = delta;

      this.sim.gpuCompute.compute();

      mesh.material.uniforms.posMap.value = this.sim.gpuCompute.getCurrentRenderTarget(this.sim.pos).texture;
      mesh.material.uniforms.velMap.value = this.sim.gpuCompute.getCurrentRenderTarget(this.sim.vel).texture;

      // timer
      mesh.material.uniforms.uTick.value = time;

      this.objType[this.objNum].visible = true;

      if (this.webgl.controls.props.backSide) {
        mesh.material.uniforms.isEdge.value = true;
        mesh.material.side = THREE.BackSide;
        this.webgl.renderer.render(this.scene, this.camera, this.fbo);
      }

      if (this.webgl.controls.props.frontSide) {
        mesh.material.uniforms.isEdge.value = false;
        mesh.material.side = THREE.FrontSide;
        this.webgl.renderer.render(this.scene, this.camera, this.fbo);
      }

      this.objType[this.objNum].visible = false;
    }
  }]);

  return ColorTex;
})();
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Controls = (function () {
  function Controls(webgl) {
    _classCallCheck(this, Controls);

    this.webgl = webgl;

    this.props = {
      pallete: ['#ffe100', '#44dee8', '#fa2c98', '#ffffff'],
      edgeColor: '#69145a',
      bgColor: '#ff2f6c',
      objType: null,
      backSide: true,
      frontSide: true,
      edgeSize: 0.38,
      shading: true
    };
  }

  _createClass(Controls, [{
    key: 'init',
    value: function init() {
      this.colorTex = this.webgl.colorTex;
      this.props.objType = this.colorTex.objTypeName[0];
      this.uColorArray = this.colorTex.material.uniforms.uColorArray;

      this.gui = new dat.GUI({ width: 300 });

      this.gui_objColor = this.gui.addFolder('obj color');
      this.gui_objColor.open();

      this.gui_objColor.addColor(this.props.pallete, 0).name('obj color 1').onChange(this.colorFunc1.bind(this));
      this.gui_objColor.addColor(this.props.pallete, 1).name('obj color 2').onChange(this.colorFunc2.bind(this));
      this.gui_objColor.addColor(this.props.pallete, 2).name('obj color 3').onChange(this.colorFunc3.bind(this));
      this.gui_objColor.addColor(this.props.pallete, 3).name('obj color 4').onChange(this.colorFunc4.bind(this));

      this.gui.addColor(this.props, 'edgeColor').name('edge color').onChange(this.colorFunc_edge.bind(this));
      this.gui.addColor(this.props, 'bgColor').name('bg color').onChange(this.colorFunc_bg.bind(this));

      this.gui.add(this.props, 'objType', this.colorTex.objTypeName).name('obj type').onFinishChange(this.objTypeFunc.bind(this));

      this.gui.add(this.props, 'backSide').name('outline color');
      this.gui.add(this.props, 'frontSide').name('obj color');
      this.gui.add(this.props, 'edgeSize', 0.1, 0.6).name('edge size').onChange(this.edgeSize.bind(this));
      this.gui.add(this.props, 'shading').onChange(this.shading.bind(this));
    }
  }, {
    key: 'colorFunc1',
    value: function colorFunc1(value) {
      var color = new THREE.Color(value);
      this.uColorArray.value[0] = color;
    }
  }, {
    key: 'colorFunc2',
    value: function colorFunc2(value) {
      var color = new THREE.Color(value);
      this.uColorArray.value[1] = color;
    }
  }, {
    key: 'colorFunc3',
    value: function colorFunc3(value) {
      var color = new THREE.Color(value);
      this.uColorArray.value[2] = color;
    }
  }, {
    key: 'colorFunc4',
    value: function colorFunc4(value) {
      var color = new THREE.Color(value);
      this.uColorArray.value[3] = color;
    }
  }, {
    key: 'colorFunc_edge',
    value: function colorFunc_edge(value) {
      var color = new THREE.Color(value);
      // this.webgl.uniforms.uEdgeColor.value = color;
      this.colorTex.material.uniforms.uEdgeColor.value = color;
    }
  }, {
    key: 'colorFunc_bg',
    value: function colorFunc_bg(value) {
      var color = new THREE.Color(value);
      this.webgl.uniforms.uBgColor.value = color;
    }
  }, {
    key: 'objTypeFunc',
    value: function objTypeFunc(value) {
      for (var i = 0, len = this.colorTex.objTypeName.length; i < len; i++) {
        if (value === this.colorTex.objTypeName[i]) {
          break;
        }
      }

      this.colorTex.objNum = i;
    }
  }, {
    key: 'edgeSize',
    value: function edgeSize(value) {
      this.colorTex.material.uniforms.uEdgeScale.value = value;
    }
  }, {
    key: 'shading',
    value: function shading(value) {
      this.colorTex.material.uniforms.isShading.value = value;
    }
  }]);

  return Controls;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResizeWatch = (function () {
  function ResizeWatch() {
    var _this = this;

    _classCallCheck(this, ResizeWatch);

    this.instances = [];

    this.width = this._width = document.body.clientWidth;
    this.height = this._height = window.innerHeight;
    this.aspect = this.width / this.height;

    window.onresize = (function () {
      if (_this.instances.length === 0) return;

      _this.width = document.body.clientWidth;
      _this.height = window.innerHeight;
      _this.aspect = _this.width / _this.height;

      for (var i = 0; i < _this.instances.length; i++) {
        _this.instances[i].resizeUpdate();
      }
    }).bind(this);
  }

  _createClass(ResizeWatch, [{
    key: "register",
    value: function register(instance) {
      this.instances.push(instance);
    }
  }]);

  return ResizeWatch;
})();

window.ResizeWatch = new ResizeWatch();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Simulation = (function () {
  function Simulation(basic, size) {
    _classCallCheck(this, Simulation);

    this.basic = basic;
    this.renderer = this.basic.renderer;
    this.size = size;
    this.init();
  }

  _createClass(Simulation, [{
    key: "init",
    value: function init() {
      this.gpuCompute = new GPUComputationRenderer(this.size, this.size, this.renderer);

      this.dataPos = this.gpuCompute.createTexture();
      this.dataVel = this.gpuCompute.createTexture();
      this.dataDef = this.gpuCompute.createTexture();

      var posArray = this.dataPos.image.data;
      var velArray = this.dataVel.image.data;
      var defArray = this.dataDef.image.data;

      for (var i = 0, il = posArray.length; i < il; i += 4) {

        var phi = Math.random() * 2 * Math.PI;
        var theta = Math.random() * Math.PI;
        var r = (1.2 + Math.random() * 2) * 1.2;

        defArray[i + 0] = posArray[i + 0] = r * Math.sin(theta) * Math.cos(phi);
        defArray[i + 1] = posArray[i + 1] = r * Math.sin(theta) * Math.sin(phi) * 1.4;
        defArray[i + 2] = posArray[i + 2] = r * Math.cos(theta);
        defArray[i + 3] = posArray[i + 3] = Math.random() * 0.5;

        velArray[i + 3] = Math.random() * 100; // frames life
      }

      this.def = this.gpuCompute.addVariable("defTex", this.basic.fragShader[1], this.dataDef);
      this.vel = this.gpuCompute.addVariable("velTex", this.basic.fragShader[2], this.dataVel);
      this.pos = this.gpuCompute.addVariable("posTex", this.basic.fragShader[3], this.dataPos);

      this.gpuCompute.setVariableDependencies(this.def, [this.pos, this.vel, this.def]);
      this.gpuCompute.setVariableDependencies(this.vel, [this.pos, this.vel, this.def]);
      this.gpuCompute.setVariableDependencies(this.pos, [this.pos, this.vel, this.def]);

      // var posUniforms = this.pos.material.uniforms;
      this.velUniforms = this.vel.material.uniforms;

      this.velUniforms.timer = { value: 0.0 };
      this.velUniforms.delta = { value: 0.0 };
      this.velUniforms.speed = { value: 0.3 };
      this.velUniforms.factor = { value: 0.5 };
      this.velUniforms.evolution = { value: 0.5 };
      this.velUniforms.radius = { value: 2.0 };

      var error = this.gpuCompute.init();
      if (error !== null) {
        console.error(error);
      }
    }
  }]);

  return Simulation;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Webgl = (function () {
  function Webgl() {
    _classCallCheck(this, Webgl);

    this.size = 32;

    this.vertShader = ["assets/glsl/output.vert", "assets/glsl/cube.vert"];

    this.fragShader = ["assets/glsl/output.frag", "assets/glsl/simulation_def.frag", "assets/glsl/simulation_vel.frag", "assets/glsl/simulation_pos.frag", "assets/glsl/cube.frag"];

    this.shaderLength = this.vertShader.length + this.fragShader.length;
    this.shaderCount = 0;

    for (var i = 0; i < this.vertShader.length; i++) {
      this.importShader_vert(i);
    }

    for (var i = 0; i < this.fragShader.length; i++) {
      this.importShader_frag(i);
    }
  }

  _createClass(Webgl, [{
    key: "importShader_vert",
    value: function importShader_vert(i) {

      var myRequest = new XMLHttpRequest();

      var _this = this;
      myRequest.onreadystatechange = function () {
        if (myRequest.readyState === 4) {
          _this.vertShader[i] = myRequest.response;
          _this.completeShaderLoad();
        }
      };

      myRequest.open("GET", this.vertShader[i], true);
      myRequest.send();
    }
  }, {
    key: "importShader_frag",
    value: function importShader_frag(i) {

      var myRequest = new XMLHttpRequest();
      // 
      var _this = this;
      myRequest.onreadystatechange = function () {
        if (myRequest.readyState === 4) {
          _this.fragShader[i] = myRequest.response;

          _this.completeShaderLoad();
        }
      };

      myRequest.open("GET", this.fragShader[i], true);
      myRequest.send();
    }
  }, {
    key: "completeShaderLoad",
    value: function completeShaderLoad() {
      this.shaderCount++;

      if (this.shaderCount === this.shaderLength) {
        this.isShaderComplete = true;
        this.init();
      }
    }
  }, {
    key: "init",
    value: function init() {
      this.width = 2048;
      this.height = 2048;
      this.aspect = this.width / this.height;
      this.setProps();
      this.container = document.getElementById("wrapper");

      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });

      this.renderer.autoClear = false;
      // renderer.setPixelRatio( window.devicePixelRatio );
      this.renderer.setSize(ResizeWatch.width, ResizeWatch.height);
      this.renderer.setClearColor(0xffffff, 0.0);
      this.container.appendChild(this.renderer.domElement);

      var ratio = Useragnt.pc ? 1.0 : 2.0;

      this.renderer.setPixelRatio(ratio);

      this.scene = new THREE.Scene();

      this.camera = new THREE.PerspectiveCamera(this.props.fov, this.props.aspect, this.props.near, this.props.far);
      var cameraZ = this.props.height / 2 / Math.tan(this.props.fov * Math.PI / 180 / 2);
      this.camera.position.set(0, 0, cameraZ);
      this.camera.lookAt(this.scene.position);

      this.controls = new Controls(this);

      this.colorTex = new ColorTex(this);

      this.createPlane();

      this.controls.init();

      this.time = new THREE.Clock();
      this.render();

      ResizeWatch.register(this);
    }
  }, {
    key: "setProps",
    value: function setProps() {
      var width = ResizeWatch.width;
      var height = ResizeWatch.height;
      var aspect = width / height;

      this.props = {
        width: width,
        height: height,
        aspect: aspect,
        fov: 45,
        left: -width / 2,
        right: width / 2,
        top: height / 2,
        bottom: -height / 2,
        near: 0.1,
        far: 10000,
        parent: document.getElementById("wrapper")
      };
    }
  }, {
    key: "createPlane",
    value: function createPlane() {
      var g = new THREE.PlaneBufferGeometry(this.width, this.height);

      this.uniforms = {
        uTex_1: { type: "t", value: this.colorTex.fbo.texture },
        uTick: { type: "f", value: 0 },
        uSize: { type: "v2", value: new THREE.Vector2(this.width, this.height) },
        // uEdgeColor: {type: "v3", value: new THREE.Color(this.edgeColor)},
        uBgColor: { type: "v3", value: new THREE.Color(this.controls.props.bgColor) }
      };

      var m = new THREE.ShaderMaterial({
        vertexShader: this.vertShader[0],
        fragmentShader: this.fragShader[0],
        uniforms: this.uniforms
      });

      var mesh = new THREE.Mesh(g, m);

      mesh.position.z = 10;
      this.scene.add(mesh);

      this.plane = mesh;

      console.log(this.plane);

      if (ResizeWatch.aspect > this.aspect) {
        var scale = ResizeWatch.width / this.width;
      } else {
        var scale = ResizeWatch.height / this.height;
      }

      this.plane.scale.x = scale;
      this.plane.scale.y = scale;
    }
  }, {
    key: "render",
    value: function render() {
      var delta = this.time.getDelta() * 5;
      var time = this.time.elapsedTime;

      this.renderer.clear();

      this.colorTex.render(time, delta);
      this.uniforms.uTick.value = time;

      this.renderer.render(this.scene, this.camera);

      requestAnimationFrame(this.render.bind(this));
    }
  }, {
    key: "resizeUpdate",
    value: function resizeUpdate() {
      this.setProps();
      this.renderer.setSize(this.props.width, this.props.height);

      this.camera.aspect = this.props.aspect;

      var cameraZ = this.props.height / 2 / Math.tan(this.props.fov * Math.PI / 180 / 2);

      this.camera.position.set(0, 0, cameraZ);
      this.camera.lookAt(this.scene.position);

      this.camera.updateProjectionMatrix();

      if (ResizeWatch.aspect > this.aspect) {
        var scale = ResizeWatch.width / this.width;
      } else {
        var scale = ResizeWatch.height / this.height;
      }

      this.plane.scale.x = scale;
      this.plane.scale.y = scale;
    }
  }]);

  return Webgl;
})();
"use strict";

window.onload = function () {
  var webgl = new Webgl();
};